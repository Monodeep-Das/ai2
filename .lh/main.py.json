{
    "sourceFile": "main.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1725604134619,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725604167663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,11 +3,12 @@\n import pandas as pd\n import matplotlib.pyplot as plt\n import io\n import base64\n-from typing import List\n+from typing import List, Tuple\n import json\n-from geopy.geocoders import Nominatim  # For geocoding\n+from geopy.geocoders import Nominatim\n+from geopy.distance import geodesic  # To calculate distances between lat/lon coordinates\n \n # Set up logging\n import logging\n logging.basicConfig(level=logging.INFO)\n@@ -26,21 +27,32 @@\n     location: Location  # Updated to use real addresses\n     day_of_week: str\n     special_event: str\n \n+class CurrentLocation(BaseModel):\n+    address: str  # User's current address for finding nearest delivery location\n+\n process_data = APIRouter()\n \n # Function to get latitude and longitude from address\n-def get_lat_lon(address):\n+def get_lat_lon(address: str) -> Tuple[float, float]:\n     geolocator = Nominatim(user_agent=\"geoapiExercises\")\n     location = geolocator.geocode(address)\n     if location:\n         return location.latitude, location.longitude\n     else:\n         raise ValueError(f\"Could not find coordinates for address: {address}\")\n \n+# Function to calculate nearest delivery location\n+def find_nearest_location(user_lat: float, user_lon: float, locations: pd.DataFrame) -> str:\n+    locations['distance'] = locations.apply(\n+        lambda row: geodesic((user_lat, user_lon), (row['latitude'], row['longitude'])).km, axis=1\n+    )\n+    nearest_location = locations.loc[locations['distance'].idxmin()]\n+    return nearest_location['location_key'], nearest_location['distance']\n+\n @process_data.post(\"/process-data/\")\n-async def process_data_endpoint(data: List[DeliveryData]):\n+async def process_data_endpoint(data: List[DeliveryData], current_location: CurrentLocation):\n     try:\n         # Load the JSON data\n         with open('delivery.json', 'r') as file:\n             delivery_data = json.load(file)\n@@ -71,8 +83,12 @@\n             preferred_times = group_df['preferred_time_minutes'].tolist()\n             optimal_delivery_time = min(preferred_times)\n             optimal_delivery_times[location_key] = optimal_delivery_time\n \n+        # Find the nearest delivery location from the user's current location\n+        user_lat, user_lon = get_lat_lon(current_location.address)\n+        nearest_location, distance = find_nearest_location(user_lat, user_lon, df)\n+\n         # Create and save visualization\n         plt.figure(figsize=(10, 6))\n         plt.scatter(\n             df['preferred_time_minutes'],\n@@ -91,12 +107,15 @@\n         plt.close()  # Close the plot to free memory\n \n         return {\n             'optimal_delivery_times': optimal_delivery_times,\n+            'nearest_location': {\n+                'location': nearest_location,\n+                'distance_km': distance\n+            },\n             'visualization': f'data:image/png;base64,{img_base64}'\n         }\n     except Exception as e:\n         logging.error(f\"Exception occurred: {str(e)}\")\n         raise HTTPException(status_code=500, detail=str(e))\n \n-\n app.include_router(process_data)\n"
                },
                {
                    "date": 1725605002086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,36 +1,24 @@\n from fastapi import FastAPI, HTTPException, APIRouter\n from pydantic import BaseModel\n+from typing import Tuple\n import pandas as pd\n-import matplotlib.pyplot as plt\n-import io\n-import base64\n-from typing import List, Tuple\n+from geopy.geocoders import Nominatim\n+from geopy.distance import geodesic\n import json\n-from geopy.geocoders import Nominatim\n-from geopy.distance import geodesic  # To calculate distances between lat/lon coordinates\n+import logging\n \n # Set up logging\n-import logging\n logging.basicConfig(level=logging.INFO)\n \n app = FastAPI()\n \n-# Define the data model for delivery data\n+# Define the data model\n class Location(BaseModel):\n     address: str  # Real address string\n \n-class DeliveryData(BaseModel):\n-    recipient_id: str\n-    preferred_time: str  # Assuming HH:MM format\n-    delivery_date: str\n-    delivery_time: str   # Assuming HH:MM format\n-    location: Location  # Updated to use real addresses\n-    day_of_week: str\n-    special_event: str\n-\n class CurrentLocation(BaseModel):\n-    address: str  # User's current address for finding nearest delivery location\n+    address: str  # User's current address for finding the nearest delivery location\n \n process_data = APIRouter()\n \n # Function to get latitude and longitude from address\n@@ -41,79 +29,42 @@\n         return location.latitude, location.longitude\n     else:\n         raise ValueError(f\"Could not find coordinates for address: {address}\")\n \n-# Function to calculate nearest delivery location\n-def find_nearest_location(user_lat: float, user_lon: float, locations: pd.DataFrame) -> str:\n+# Function to calculate the nearest delivery location\n+def find_nearest_location(user_lat: float, user_lon: float, locations: pd.DataFrame) -> Tuple[str, float]:\n     locations['distance'] = locations.apply(\n         lambda row: geodesic((user_lat, user_lon), (row['latitude'], row['longitude'])).km, axis=1\n     )\n     nearest_location = locations.loc[locations['distance'].idxmin()]\n     return nearest_location['location_key'], nearest_location['distance']\n \n @process_data.post(\"/process-data/\")\n-async def process_data_endpoint(data: List[DeliveryData], current_location: CurrentLocation):\n+async def process_data_endpoint(current_location: CurrentLocation):\n     try:\n-        # Load the JSON data\n+        # Load the delivery data from JSON file\n         with open('delivery.json', 'r') as file:\n             delivery_data = json.load(file)\n \n-        # Convert list of DeliveryData to DataFrame\n-        df = pd.DataFrame([item.dict() for item in data])\n+        # Convert delivery data to DataFrame\n+        df = pd.DataFrame(delivery_data)\n+        if df.empty:\n+            raise HTTPException(status_code=404, detail=\"No delivery addresses found\")\n \n-        # Convert time columns to datetime\n-        try:\n-            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n-        except ValueError:\n-            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n-\n-        # Convert time columns to minutes since midnight for analysis and prediction\n-        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n-\n-        # Geocode addresses to get latitude and longitude\n+        # Geocode delivery addresses to get latitude and longitude\n         df['latitude'], df['longitude'] = zip(*df['location'].apply(lambda loc: get_lat_lon(loc['address'])))\n \n-        # Group the data by location and find the optimal delivery time for each location\n-        df['location_key'] = df.apply(lambda row: f\"{row['latitude']}, {row['longitude']}\", axis=1)\n-        location_groups = df.groupby('location_key')\n-        optimal_delivery_times = {}\n+        # Geocode the user's current address\n+        user_lat, user_lon = get_lat_lon(current_location.address)\n \n-        for location_key, group_df in location_groups:\n-            preferred_times = group_df['preferred_time_minutes'].tolist()\n-            optimal_delivery_time = min(preferred_times)\n-            optimal_delivery_times[location_key] = optimal_delivery_time\n-\n-        # Find the nearest delivery location from the user's current location\n-        user_lat, user_lon = get_lat_lon(current_location.address)\n+        # Find the nearest delivery location\n         nearest_location, distance = find_nearest_location(user_lat, user_lon, df)\n \n-        # Create and save visualization\n-        plt.figure(figsize=(10, 6))\n-        plt.scatter(\n-            df['preferred_time_minutes'],\n-            df['delivery_time_minutes'],\n-            alpha=0.5\n-        )\n-        plt.title('Preferred Time vs Delivery Time')\n-        plt.xlabel('Preferred Time (Minutes since Midnight)')\n-        plt.ylabel('Delivery Time (Minutes since Midnight)')\n-        plt.grid(True)\n-\n-        buf = io.BytesIO()\n-        plt.savefig(buf, format='png')\n-        buf.seek(0)\n-        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n-        plt.close()  # Close the plot to free memory\n-\n         return {\n-            'optimal_delivery_times': optimal_delivery_times,\n             'nearest_location': {\n                 'location': nearest_location,\n                 'distance_km': distance\n-            },\n-            'visualization': f'data:image/png;base64,{img_base64}'\n+            }\n         }\n     except Exception as e:\n         logging.error(f\"Exception occurred: {str(e)}\")\n         raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725605112985,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,16 +43,23 @@\n     try:\n         # Load the delivery data from JSON file\n         with open('delivery.json', 'r') as file:\n             delivery_data = json.load(file)\n+        \n+        if not delivery_data:\n+            raise HTTPException(status_code=404, detail=\"No delivery addresses found\")\n \n         # Convert delivery data to DataFrame\n         df = pd.DataFrame(delivery_data)\n-        if df.empty:\n-            raise HTTPException(status_code=404, detail=\"No delivery addresses found\")\n+        \n+        if 'address' not in df.columns:\n+            raise HTTPException(status_code=400, detail=\"Invalid delivery data format. 'address' column is missing\")\n \n         # Geocode delivery addresses to get latitude and longitude\n-        df['latitude'], df['longitude'] = zip(*df['location'].apply(lambda loc: get_lat_lon(loc['address'])))\n+        try:\n+            df['latitude'], df['longitude'] = zip(*df['address'].apply(lambda addr: get_lat_lon(addr)))\n+        except ValueError as e:\n+            raise HTTPException(status_code=400, detail=str(e))\n \n         # Geocode the user's current address\n         user_lat, user_lon = get_lat_lon(current_location.address)\n \n"
                },
                {
                    "date": 1725605974711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,9 @@\n from fastapi import FastAPI, HTTPException, APIRouter\n from pydantic import BaseModel\n from typing import Tuple\n import pandas as pd\n-from geopy.geocoders import Nominatim\n-from geopy.distance import geodesic\n+import requests\n import json\n import logging\n \n # Set up logging\n@@ -20,16 +19,28 @@\n     address: str  # User's current address for finding the nearest delivery location\n \n process_data = APIRouter()\n \n-# Function to get latitude and longitude from address\n+# OpenCage Geocoding API key and endpoint\n+OPENCAGE_API_KEY = \"49f2530ec11943f092d25acb9bfaff2b\"\n+OPENCAGE_API_URL = \"https://api.opencagedata.com/geocode/v1/json\"\n+\n+# Function to get latitude and longitude from address using OpenCage\n def get_lat_lon(address: str) -> Tuple[float, float]:\n-    geolocator = Nominatim(user_agent=\"geoapiExercises\")\n-    location = geolocator.geocode(address)\n-    if location:\n-        return location.latitude, location.longitude\n+    params = {\n+        'q': address,\n+        'key': OPENCAGE_API_KEY\n+    }\n+    response = requests.get(OPENCAGE_API_URL, params=params)\n+    if response.status_code == 200:\n+        results = response.json().get('results', [])\n+        if results:\n+            location = results[0]['geometry']\n+            return location['lat'], location['lng']\n+        else:\n+            raise ValueError(f\"Could not find coordinates for address: {address}\")\n     else:\n-        raise ValueError(f\"Could not find coordinates for address: {address}\")\n+        raise HTTPException(status_code=response.status_code, detail=\"Geocoding API request failed\")\n \n # Function to calculate the nearest delivery location\n def find_nearest_location(user_lat: float, user_lon: float, locations: pd.DataFrame) -> Tuple[str, float]:\n     locations['distance'] = locations.apply(\n@@ -43,23 +54,16 @@\n     try:\n         # Load the delivery data from JSON file\n         with open('delivery.json', 'r') as file:\n             delivery_data = json.load(file)\n-        \n-        if not delivery_data:\n-            raise HTTPException(status_code=404, detail=\"No delivery addresses found\")\n \n         # Convert delivery data to DataFrame\n         df = pd.DataFrame(delivery_data)\n-        \n-        if 'address' not in df.columns:\n-            raise HTTPException(status_code=400, detail=\"Invalid delivery data format. 'address' column is missing\")\n+        if df.empty:\n+            raise HTTPException(status_code=404, detail=\"No delivery addresses found\")\n \n         # Geocode delivery addresses to get latitude and longitude\n-        try:\n-            df['latitude'], df['longitude'] = zip(*df['address'].apply(lambda addr: get_lat_lon(addr)))\n-        except ValueError as e:\n-            raise HTTPException(status_code=400, detail=str(e))\n+        df['latitude'], df['longitude'] = zip(*df['address'].apply(lambda addr: get_lat_lon(addr)))\n \n         # Geocode the user's current address\n         user_lat, user_lon = get_lat_lon(current_location.address)\n \n"
                },
                {
                    "date": 1725606109049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,10 @@\n from fastapi import FastAPI, HTTPException, APIRouter\n from pydantic import BaseModel\n from typing import Tuple\n import pandas as pd\n-import requests\n+from geopy.geocoders import OpenCage\n+from geopy.distance import geodesic\n import json\n import logging\n \n # Set up logging\n@@ -19,28 +20,22 @@\n     address: str  # User's current address for finding the nearest delivery location\n \n process_data = APIRouter()\n \n-# OpenCage Geocoding API key and endpoint\n-OPENCAGE_API_KEY = \"49f2530ec11943f092d25acb9bfaff2b\"\n-OPENCAGE_API_URL = \"https://api.opencagedata.com/geocode/v1/json\"\n+# Initialize OpenCage geocoder\n+geocoder = OpenCage(api_key=\"49f2530ec11943f092d25acb9bfaff2b\")\n \n-# Function to get latitude and longitude from address using OpenCage\n+# Function to get latitude and longitude from address\n def get_lat_lon(address: str) -> Tuple[float, float]:\n-    params = {\n-        'q': address,\n-        'key': OPENCAGE_API_KEY\n-    }\n-    response = requests.get(OPENCAGE_API_URL, params=params)\n-    if response.status_code == 200:\n-        results = response.json().get('results', [])\n-        if results:\n-            location = results[0]['geometry']\n-            return location['lat'], location['lng']\n+    try:\n+        response = geocoder.geocode(address)\n+        if response and response.results:\n+            location = response.results[0]\n+            return location.geometry['lat'], location.geometry['lng']\n         else:\n             raise ValueError(f\"Could not find coordinates for address: {address}\")\n-    else:\n-        raise HTTPException(status_code=response.status_code, detail=\"Geocoding API request failed\")\n+    except Exception as e:\n+        raise ValueError(f\"Error occurred while geocoding address: {str(e)}\")\n \n # Function to calculate the nearest delivery location\n def find_nearest_location(user_lat: float, user_lon: float, locations: pd.DataFrame) -> Tuple[str, float]:\n     locations['distance'] = locations.apply(\n"
                },
                {
                    "date": 1725606209580,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n from fastapi import FastAPI, HTTPException, APIRouter\n from pydantic import BaseModel\n from typing import Tuple\n import pandas as pd\n-from geopy.geocoders import OpenCage\n+from opencage.geocoder import OpenCageGeocode\n from geopy.distance import geodesic\n import json\n import logging\n \n@@ -21,17 +21,17 @@\n \n process_data = APIRouter()\n \n # Initialize OpenCage geocoder\n-geocoder = OpenCage(api_key=\"49f2530ec11943f092d25acb9bfaff2b\")\n+geocoder = OpenCageGeocode(\"49f2530ec11943f092d25acb9bfaff2b\")\n \n # Function to get latitude and longitude from address\n def get_lat_lon(address: str) -> Tuple[float, float]:\n     try:\n-        response = geocoder.geocode(address)\n-        if response and response.results:\n-            location = response.results[0]\n-            return location.geometry['lat'], location.geometry['lng']\n+        results = geocoder.geocode(address)\n+        if results and results:\n+            location = results[0]  # Get the first result\n+            return location['geometry']['lat'], location['geometry']['lng']\n         else:\n             raise ValueError(f\"Could not find coordinates for address: {address}\")\n     except Exception as e:\n         raise ValueError(f\"Error occurred while geocoding address: {str(e)}\")\n"
                },
                {
                    "date": 1725606296602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,13 +37,21 @@\n         raise ValueError(f\"Error occurred while geocoding address: {str(e)}\")\n \n # Function to calculate the nearest delivery location\n def find_nearest_location(user_lat: float, user_lon: float, locations: pd.DataFrame) -> Tuple[str, float]:\n+    # Print DataFrame columns for debugging\n+    print(\"DataFrame columns:\", locations.columns)\n+    \n+    # Check if the required columns exist\n+    if 'latitude' not in locations.columns or 'longitude' not in locations.columns:\n+        raise ValueError(\"DataFrame must contain 'latitude' and 'longitude' columns\")\n+    \n+    # Calculate distances\n     locations['distance'] = locations.apply(\n         lambda row: geodesic((user_lat, user_lon), (row['latitude'], row['longitude'])).km, axis=1\n     )\n     nearest_location = locations.loc[locations['distance'].idxmin()]\n-    return nearest_location['location_key'], nearest_location['distance']\n+    return nearest_location['address'], nearest_location['distance']\n \n @process_data.post(\"/process-data/\")\n async def process_data_endpoint(current_location: CurrentLocation):\n     try:\n@@ -52,13 +60,16 @@\n             delivery_data = json.load(file)\n \n         # Convert delivery data to DataFrame\n         df = pd.DataFrame(delivery_data)\n+        print(\"DataFrame loaded:\", df.head())  # Debugging line to see the DataFrame\n+        \n+        # Check if DataFrame is empty\n         if df.empty:\n             raise HTTPException(status_code=404, detail=\"No delivery addresses found\")\n \n         # Geocode delivery addresses to get latitude and longitude\n-        df['latitude'], df['longitude'] = zip(*df['address'].apply(lambda addr: get_lat_lon(addr)))\n+        df[['latitude', 'longitude']] = df['address'].apply(lambda addr: pd.Series(get_lat_lon(addr)))\n \n         # Geocode the user's current address\n         user_lat, user_lon = get_lat_lon(current_location.address)\n \n"
                },
                {
                    "date": 1725607485943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n # Function to get latitude and longitude from address\n def get_lat_lon(address: str) -> Tuple[float, float]:\n     try:\n         results = geocoder.geocode(address)\n-        if results and results:\n+        if results and len(results) > 0:\n             location = results[0]  # Get the first result\n             return location['geometry']['lat'], location['geometry']['lng']\n         else:\n             raise ValueError(f\"Could not find coordinates for address: {address}\")\n@@ -38,9 +38,9 @@\n \n # Function to calculate the nearest delivery location\n def find_nearest_location(user_lat: float, user_lon: float, locations: pd.DataFrame) -> Tuple[str, float]:\n     # Print DataFrame columns for debugging\n-    print(\"DataFrame columns:\", locations.columns)\n+    logging.info(\"DataFrame columns: %s\", locations.columns)\n     \n     # Check if the required columns exist\n     if 'latitude' not in locations.columns or 'longitude' not in locations.columns:\n         raise ValueError(\"DataFrame must contain 'latitude' and 'longitude' columns\")\n@@ -48,8 +48,10 @@\n     # Calculate distances\n     locations['distance'] = locations.apply(\n         lambda row: geodesic((user_lat, user_lon), (row['latitude'], row['longitude'])).km, axis=1\n     )\n+    \n+    # Find the nearest location\n     nearest_location = locations.loc[locations['distance'].idxmin()]\n     return nearest_location['address'], nearest_location['distance']\n \n @process_data.post(\"/process-data/\")\n@@ -60,9 +62,9 @@\n             delivery_data = json.load(file)\n \n         # Convert delivery data to DataFrame\n         df = pd.DataFrame(delivery_data)\n-        print(\"DataFrame loaded:\", df.head())  # Debugging line to see the DataFrame\n+        logging.info(\"DataFrame loaded: %s\", df.head())  # Debugging line to see the DataFrame\n         \n         # Check if DataFrame is empty\n         if df.empty:\n             raise HTTPException(status_code=404, detail=\"No delivery addresses found\")\n@@ -71,19 +73,21 @@\n         df[['latitude', 'longitude']] = df['address'].apply(lambda addr: pd.Series(get_lat_lon(addr)))\n \n         # Geocode the user's current address\n         user_lat, user_lon = get_lat_lon(current_location.address)\n+        logging.info(\"User location: Latitude %f, Longitude %f\", user_lat, user_lon)\n \n         # Find the nearest delivery location\n         nearest_location, distance = find_nearest_location(user_lat, user_lon, df)\n+        logging.info(\"Nearest location: %s, Distance: %f\", nearest_location, distance)\n \n         return {\n             'nearest_location': {\n                 'location': nearest_location,\n                 'distance_km': distance\n             }\n         }\n     except Exception as e:\n-        logging.error(f\"Exception occurred: {str(e)}\")\n+        logging.error(\"Exception occurred: %s\", str(e))\n         raise HTTPException(status_code=500, detail=str(e))\n \n app.include_router(process_data)\n"
                },
                {
                    "date": 1725611590165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n from fastapi import FastAPI, HTTPException, APIRouter\n+from fastapi.middleware.cors import CORSMiddleware\n from pydantic import BaseModel\n from typing import Tuple\n import pandas as pd\n from opencage.geocoder import OpenCageGeocode\n@@ -11,8 +12,17 @@\n logging.basicConfig(level=logging.INFO)\n \n app = FastAPI()\n \n+# Set up CORS\n+app.add_middleware(\n+    CORSMiddleware,\n+    allow_origins=[\"http://localhost:3000\"],  # Your React app URL or \"*\" to allow all origins\n+    allow_credentials=True,\n+    allow_methods=[\"*\"],  # Allow all methods (POST, GET, etc.)\n+    allow_headers=[\"*\"],  # Allow all headers\n+)\n+\n # Define the data model\n class Location(BaseModel):\n     address: str  # Real address string\n \n"
                },
                {
                    "date": 1725612981374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,103 +1,99 @@\n-from fastapi import FastAPI, HTTPException, APIRouter\n-from fastapi.middleware.cors import CORSMiddleware\n-from pydantic import BaseModel\n-from typing import Tuple\n-import pandas as pd\n-from opencage.geocoder import OpenCageGeocode\n-from geopy.distance import geodesic\n-import json\n-import logging\n+\"use client\";\n+import React, { useState } from \"react\";\n+import Navbar from \"@/components/NavBar\";\n+import Footer from \"@/components/Footer\";\n+import { GoogleMap, DirectionsRenderer, LoadScript } from \"@react-google-maps/api\";\n \n-# Set up logging\n-logging.basicConfig(level=logging.INFO)\n+const containerStyle = {\n+    width: \"100%\",\n+    height: \"500px\",\n+};\n \n-app = FastAPI()\n+const center = {\n+    lat: 20.5937, // Latitude for India\n+    lng: 78.9629, // Longitude for India\n+};\n \n-# Set up CORS\n-app.add_middleware(\n-    CORSMiddleware,\n-    allow_origins=[\"http://localhost:3000\"],  # Your React app URL or \"*\" to allow all origins\n-    allow_credentials=True,\n-    allow_methods=[\"*\"],  # Allow all methods (POST, GET, etc.)\n-    allow_headers=[\"*\"],  # Allow all headers\n-)\n+const HeroReact: React.FC = () => {\n+    const [address, setAddress] = useState<string>(\"\"); // Address input for the POST request\n+    const [nearestLocation, setNearestLocation] = useState<string | null>(null); // Nearest location from API\n+    const [distance, setDistance] = useState<number | null>(null); // Distance from API\n+    const [directionsResponse, setDirectionsResponse] = useState<google.maps.DirectionsResult | null>(null);\n+    const [errorMessage, setErrorMessage] = useState<string>(\"\");\n \n-# Define the data model\n-class Location(BaseModel):\n-    address: str  # Real address string\n+    const handleAddressSubmit = async () => {\n+        try {\n+            const response = await fetch(\"http://127.0.0.1:8080/process-data/\", {\n+                method: \"POST\",\n+                headers: {\n+                    \"Content-Type\": \"application/json\",\n+                },\n+                body: JSON.stringify({ address }),\n+            });\n \n-class CurrentLocation(BaseModel):\n-    address: str  # User's current address for finding the nearest delivery location\n+            if (!response.ok) {\n+                throw new Error(\"Failed to send the address.\");\n+            }\n \n-process_data = APIRouter()\n+            const data = await response.json();\n+            console.log(\"Response from server:\", data);\n+            \n+            // Update state with the nearest location and distance from API response\n+            setNearestLocation(data.nearest_location.location);\n+            setDistance(data.nearest_location.distance_km);\n+        } catch (error) {\n+            console.error(\"Error sending address:\", error);\n+            setErrorMessage(\"An error occurred while sending the address.\");\n+        }\n+    };\n \n-# Initialize OpenCage geocoder\n-geocoder = OpenCageGeocode(\"49f2530ec11943f092d25acb9bfaff2b\")\n+    return (\n+        <>\n+            <Navbar />\n+            <div className=\"sm:min-h-[120vh] flex flex-col items-center justify-start px-1 z-10 bg-cover bg-center bg-no-repeat\">\n+                <div className=\"w-full h-96 mt-8\">\n+                    <LoadScript\n+                        googleMapsApiKey=\"YOUR_GOOGLE_MAPS_API_KEY\"\n+                        onError={(error) => console.error(\"Google Maps API Error: \", error)}\n+                    >\n+                        <GoogleMap\n+                            mapContainerStyle={containerStyle}\n+                            center={center}\n+                            zoom={5}\n+                        >\n+                            {directionsResponse && <DirectionsRenderer directions={directionsResponse} />}\n+                        </GoogleMap>\n+                    </LoadScript>\n+                </div>\n \n-# Function to get latitude and longitude from address\n-def get_lat_lon(address: str) -> Tuple[float, float]:\n-    try:\n-        results = geocoder.geocode(address)\n-        if results and len(results) > 0:\n-            location = results[0]  # Get the first result\n-            return location['geometry']['lat'], location['geometry']['lng']\n-        else:\n-            raise ValueError(f\"Could not find coordinates for address: {address}\")\n-    except Exception as e:\n-        raise ValueError(f\"Error occurred while geocoding address: {str(e)}\")\n+                <div className=\"mt-8 flex flex-col items-center mt-36\">\n+                    <input\n+                        type=\"text\"\n+                        placeholder=\"Enter address\"\n+                        value={address}\n+                        onChange={(e) => setAddress(e.target.value)}\n+                        className=\"p-2 border border-gray-300 rounded mb-4\"\n+                    />\n+                    <button\n+                        onClick={handleAddressSubmit}\n+                        className=\"bg-blue-500 text-white px-4 py-2 rounded\"\n+                    >\n+                        Send Address\n+                    </button>\n \n-# Function to calculate the nearest delivery location\n-def find_nearest_location(user_lat: float, user_lon: float, locations: pd.DataFrame) -> Tuple[str, float]:\n-    # Print DataFrame columns for debugging\n-    logging.info(\"DataFrame columns: %s\", locations.columns)\n-    \n-    # Check if the required columns exist\n-    if 'latitude' not in locations.columns or 'longitude' not in locations.columns:\n-        raise ValueError(\"DataFrame must contain 'latitude' and 'longitude' columns\")\n-    \n-    # Calculate distances\n-    locations['distance'] = locations.apply(\n-        lambda row: geodesic((user_lat, user_lon), (row['latitude'], row['longitude'])).km, axis=1\n-    )\n-    \n-    # Find the nearest location\n-    nearest_location = locations.loc[locations['distance'].idxmin()]\n-    return nearest_location['address'], nearest_location['distance']\n+                    {errorMessage && <p className=\"text-red-500 mt-4\">{errorMessage}</p>}\n+                    \n+                    {nearestLocation && distance !== null && (\n+                        <div className=\"mt-4 p-4 border border-gray-300 rounded\">\n+                            <p>Nearest Location: {nearestLocation}</p>\n+                            <p>Distance: {distance.toFixed(2)} km</p>\n+                        </div>\n+                    )}\n+                </div>\n+            </div >\n+            <Footer />\n+        </>\n+    );\n+};\n \n-@process_data.post(\"/process-data/\")\n-async def process_data_endpoint(current_location: CurrentLocation):\n-    try:\n-        # Load the delivery data from JSON file\n-        with open('delivery.json', 'r') as file:\n-            delivery_data = json.load(file)\n-\n-        # Convert delivery data to DataFrame\n-        df = pd.DataFrame(delivery_data)\n-        logging.info(\"DataFrame loaded: %s\", df.head())  # Debugging line to see the DataFrame\n-        \n-        # Check if DataFrame is empty\n-        if df.empty:\n-            raise HTTPException(status_code=404, detail=\"No delivery addresses found\")\n-\n-        # Geocode delivery addresses to get latitude and longitude\n-        df[['latitude', 'longitude']] = df['address'].apply(lambda addr: pd.Series(get_lat_lon(addr)))\n-\n-        # Geocode the user's current address\n-        user_lat, user_lon = get_lat_lon(current_location.address)\n-        logging.info(\"User location: Latitude %f, Longitude %f\", user_lat, user_lon)\n-\n-        # Find the nearest delivery location\n-        nearest_location, distance = find_nearest_location(user_lat, user_lon, df)\n-        logging.info(\"Nearest location: %s, Distance: %f\", nearest_location, distance)\n-\n-        return {\n-            'nearest_location': {\n-                'location': nearest_location,\n-                'distance_km': distance\n-            }\n-        }\n-    except Exception as e:\n-        logging.error(\"Exception occurred: %s\", str(e))\n-        raise HTTPException(status_code=500, detail=str(e))\n-\n-app.include_router(process_data)\n+export default HeroReact;\n"
                }
            ],
            "date": 1725604134619,
            "name": "Commit-0",
            "content": "from fastapi import FastAPI, HTTPException, APIRouter\nfrom pydantic import BaseModel\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport io\nimport base64\nfrom typing import List\nimport json\nfrom geopy.geocoders import Nominatim  # For geocoding\n\n# Set up logging\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\napp = FastAPI()\n\n# Define the data model for delivery data\nclass Location(BaseModel):\n    address: str  # Real address string\n\nclass DeliveryData(BaseModel):\n    recipient_id: str\n    preferred_time: str  # Assuming HH:MM format\n    delivery_date: str\n    delivery_time: str   # Assuming HH:MM format\n    location: Location  # Updated to use real addresses\n    day_of_week: str\n    special_event: str\n\nprocess_data = APIRouter()\n\n# Function to get latitude and longitude from address\ndef get_lat_lon(address):\n    geolocator = Nominatim(user_agent=\"geoapiExercises\")\n    location = geolocator.geocode(address)\n    if location:\n        return location.latitude, location.longitude\n    else:\n        raise ValueError(f\"Could not find coordinates for address: {address}\")\n\n@process_data.post(\"/process-data/\")\nasync def process_data_endpoint(data: List[DeliveryData]):\n    try:\n        # Load the JSON data\n        with open('delivery.json', 'r') as file:\n            delivery_data = json.load(file)\n\n        # Convert list of DeliveryData to DataFrame\n        df = pd.DataFrame([item.dict() for item in data])\n\n        # Convert time columns to datetime\n        try:\n            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n        except ValueError:\n            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n\n        # Convert time columns to minutes since midnight for analysis and prediction\n        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n\n        # Geocode addresses to get latitude and longitude\n        df['latitude'], df['longitude'] = zip(*df['location'].apply(lambda loc: get_lat_lon(loc['address'])))\n\n        # Group the data by location and find the optimal delivery time for each location\n        df['location_key'] = df.apply(lambda row: f\"{row['latitude']}, {row['longitude']}\", axis=1)\n        location_groups = df.groupby('location_key')\n        optimal_delivery_times = {}\n\n        for location_key, group_df in location_groups:\n            preferred_times = group_df['preferred_time_minutes'].tolist()\n            optimal_delivery_time = min(preferred_times)\n            optimal_delivery_times[location_key] = optimal_delivery_time\n\n        # Create and save visualization\n        plt.figure(figsize=(10, 6))\n        plt.scatter(\n            df['preferred_time_minutes'],\n            df['delivery_time_minutes'],\n            alpha=0.5\n        )\n        plt.title('Preferred Time vs Delivery Time')\n        plt.xlabel('Preferred Time (Minutes since Midnight)')\n        plt.ylabel('Delivery Time (Minutes since Midnight)')\n        plt.grid(True)\n\n        buf = io.BytesIO()\n        plt.savefig(buf, format='png')\n        buf.seek(0)\n        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n        plt.close()  # Close the plot to free memory\n\n        return {\n            'optimal_delivery_times': optimal_delivery_times,\n            'visualization': f'data:image/png;base64,{img_base64}'\n        }\n    except Exception as e:\n        logging.error(f\"Exception occurred: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n\napp.include_router(process_data)\n"
        }
    ]
}